<!DOCTYPE html>
<html lang="en">
<head>
    <title>Vis Network | Yule Model Phylogeny</title>

    <script src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>

    <style type="text/css">
        #container {
            display: flex;
            flex-direction: column;
            width: 100%;
        }
        .row {
            display: flex;
            width: 100%;
            margin-bottom: 30px;
            border: 2px dashed #ccc; /* Dashed border with light gray color */
            border-radius: 10px; /* Rounded corners */
            min-height: 100px;
        }
        .row-button {
            display: flex;
            width: 100%;
            margin-bottom: 20px;
            justify-content: left;
        }
        .row-title {
            display: flex;
            width: 100%;
            margin-bottom: 10px;
        }
        #mynetwork-legend {
            flex: 1; /* 1/11 of the total width */
            height: 400px;
            margin-right: 0px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-left: 10px;

        }.legend-item {
             display: flex;
             align-items: center;
             margin-bottom: 10px;
         }
        .legend-circle {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-right: 10px;
            border: 2px solid; /* Add a border with a slightly darker color */
        }
        .root-circle {
            background-color: #80b3ff; /* Light Blue */
            border-color: #6699cc; /* Slightly darker blue */
        }
        .internal-circle {
            background-color: #ffd699; /* Light Orange */
            border-color: #e6b366; /* Slightly darker orange */
        }
        .tip-circle {
            background-color: #b3ff99; /* Light Lime Green */
            border-color: #99cc80; /* Slightly darker lime green */
        }
        #mynetwork {
            flex: 10; /* 10/11 of the total width */
            height: 400px;
        }
        #adjacency-list {
            flex: 1; /* Equal width for adjacency-list and node-features */
            font-family: monospace;
            font-size: 18px;
            white-space: nowrap;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            margin-top: 20px;
            margin-bottom: 20px;
        }
        #node-features {
            flex: 1; /* Equal width for adjacency-list and node-features */
            font-family: monospace;
            font-size: 17px;
            white-space: nowrap;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            margin-top: 20px;
            margin-bottom: 20px;
        }
        #adjacency-list-title {
            color: #767776;
            flex: 1;
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 10px;
            text-align: center;
            font-family: "Arial Math", Arial, sans-serif; /* Change the font to Arial Math */
            background-color: #fbf5f7;
            padding: 10px;
            margin-left: 10px;
            margin-right: 10px;
            border-radius: 10px; /* Rounded corners */
        }
        #node-features-title {
            color: #767776;
            flex: 1;
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 10px;
            text-align: center;
            font-family: "Arial Math", Arial, sans-serif; /* Change the font to Arial Math */
            background-color: #fbf5f7;
            padding: 10px;
            margin-left: 10px;
            margin-right: 10px;
            border-radius: 10px; /* Rounded corners */
        }
        .highlight {
            background-color: yellow;
            /*border: 1px dashed #e35142; !* Dashed border with light red color *!*/
            border-radius: 5px; /* Rounded corners */
        }
        .highlight-node-feature {
            background-color: lightblue;
            /*border: 1px dashed #ccc; !* Dashed border with light gray color *!*/
            border-radius: 5px; /* Rounded corners */
        }
        #node-features .highlight-node-feature {
            background-color: lightblue;
            /*border: 1px dashed #ccc; !* Dashed border with light gray color *!*/
            border-radius: 5px; /* Rounded corners */
        }
        .label-highlight {
            background-color: lightblue;
            /*border: 1px dashed #ccc; !* Dashed border with light gray color *!*/
            border-radius: 5px; /* Rounded corners */
        }
        .row-container {
            display: flex;
            align-items: center;
            padding: 1px 0;
        }
        .row-container:hover {
            background-color: yellow;
        }
        .edge-label, .node-label {
            min-width: 50px;
            text-align: right;
            padding-right: 10px;
        }
        .colon {
            padding-right: 10px;
        }
        .node-container {
            display: inline-block;
            text-align: center;
            margin-right: 5px;
        }
        .brackets {
            margin: 0 5px;
        }
    </style>
</head>
<body>
<h1>Phylogeny Playground</h1>
<p>Explore the tree in both phylogeny (dendrogram) form and graph form, with the ability to drag, zoom, and adjust the view. Experiment with generating trees of varying sizes, and interact with the nodes and edges by hovering over them. The corresponding elements in the adjacency list and node feature matrix will be highlighted for visual assistance.</p>
<p>Interactive highlighting allows you to easily trace connections between a phylogeny/graph and its encoding. For example, when you hover over an edge, its associated entries in the adjacency list and node feature matrix will be highlighted. Similarly, hovering over a row or element in the list or matrix will highlight the corresponding node or edge in the tree.</p>
<p>Try it out yourself, specify a tip number and click on the "Generate Tree" button below to simulate a phylogenetic tree under the Yule model.</p>
<p>Click on "Phlogeny Form" and "Graph Form" to switch between layouts. Click on the rotation buttons to display the tree in a different pose.</p>
<form id="treeForm">
    <label for="tipCount">Enter number of tips (T):</label>
    <input type="number" id="tipCount" name="tipCount" min="2" max="10" value="5" required>
    <button type="submit">Generate Tree</button>
</form><br>

<div class="row-button">
    <!--add button to change layout to phylogenetic tree style-->
    <button onclick="network.setOptions({layout: {hierarchical: {sortMethod: 'directed'}}})">Phylogeny Form</button>
    <!--add button to change layout to phylogenetic tree style and disable physics-->
    <button onclick="network.setOptions({layout: {hierarchical: false}, physics: true})">Graph Form</button>

    <!--Two buttons for rotation using the rotateLayout() function-->
    <button onclick="rotateLayoutClockwise()">Rotate 90&deg</button>
    <button onclick="rotateLayoutCounterClockwise()">Rotate -90&deg</button>
</div>

<!-- Two rows layout -->
<div id="container">
    <!-- First row: legend and network -->
    <div class="row">
        <div id="mynetwork-legend">
            <div id="legend-content">
                <div class="legend-item">
                    <div class="legend-circle root-circle"></div>
                    <span>Root</span>
                </div>
                <div class="legend-item">
                    <div class="legend-circle internal-circle"></div>
                    <span>Internal</span>
                </div>
                <div class="legend-item">
                    <div class="legend-circle tip-circle"></div>
                    <span>Tip</span>
                </div>
            </div>
        </div>
        <div id="mynetwork"></div>
    </div>
    <!-- Column titles for the second row -->
    <div class="row-title">
        <div id="adjacency-list-title">Adjacency List</div>
        <div id="node-features-title">Node Features</div>
    </div>
    <!-- Second row: adjacency list and node features -->
    <div class="row">
        <div id="adjacency-list">
            <div class="content">
                <!-- Adjacency list content goes here -->
            </div>
        </div>
        <div id="node-features">
            <div class="content">
                <!-- Node features content goes here -->
            </div>
        </div>
    </div>
</div>

<p id="selection"></p>

<script type="text/javascript">
    // Define colors for nodes, edges, and labels corresponding to LaTeX tikz colors
    const rootNodeColor = "#80b3ff"; // Blue!50 -> Light Blue
    const internalNodeColor = "#ffd699"; // Orange!50 -> Light Orange
    const tipNodeColor = "#b3ff99"; // Lime!50 -> Light Lime Green
    const edgeColor = "black";
    const nodeLabelColor = "black";
    const edgeLabelColor = "gray";

    const nodeSize = 30; // Increase node size

    var network, nodesDataSet, edgesDataSet;

    document.getElementById('treeForm').addEventListener('submit', function(event) {
        event.preventDefault();
        var T = parseInt(document.getElementById('tipCount').value);
        generateYuleTree(T);
    });

    function generateYuleTree(T) {
        var nodes = [];
        var edges = [];
        var nextNodeId = 1;
        var nextEdgeId = 1;

        // Initialize tree with the root node
        nodes.push({ id: nextNodeId,
            label: `n${nextNodeId}`,
            shape: "circle",
            color: rootNodeColor,
            font: { color: nodeLabelColor },
            size: nodeSize,
        });

        var activeLineages = [nextNodeId];
        nextNodeId++;
        var currentTipCount = 1;

        while (currentTipCount < T) {
            // Randomly select a lineage to split
            var lineageIndex = Math.floor(Math.random() * activeLineages.length);
            var parent = activeLineages[lineageIndex];

            // Remove the selected lineage from active lineages
            activeLineages.splice(lineageIndex, 1);

            // Add two new nodes as children of the selected lineage
            var child1 = nextNodeId++;
            var child2 = nextNodeId++;

            nodes.push({ id: child1, label: `n${child1}`, shape: "circle", color: internalNodeColor, font: { color: nodeLabelColor }, size: nodeSize });
            nodes.push({ id: child2, label: `n${child2}`, shape: "circle", color: internalNodeColor, font: { color: nodeLabelColor }, size: nodeSize });

            edges.push({ from: parent, to: child1, label: `e${nextEdgeId++}`, font: { align: 'top', color: edgeLabelColor }, color: edgeColor });
            edges.push({ from: parent, to: child2, label: `e${nextEdgeId++}`, font: { align: 'top', color: edgeLabelColor }, color: edgeColor });

            // Add the new nodes to the active lineages
            activeLineages.push(child1, child2);

            // Increment the tip count
            currentTipCount += 1;
        }

        // Update tip nodes (those that are still in activeLineages)
        activeLineages.forEach(nodeId => {
            nodes = nodes.map(node =>
                node.id === nodeId
                    ? { ...node, shape: "circle", color: tipNodeColor }
                    : node
            );
        });

        // Set all edge colors to black
        edges.forEach((edge) => {
            edge.color = edgeColor;
        });

        // Relabel nodes starting with tip nodes, then root, then internal nodes
        var tipNodes = nodes.filter(node => node.color === tipNodeColor);
        var rootNode = nodes.find(node => node.color === rootNodeColor);
        var internalNodes = nodes.filter(node => node.color === internalNodeColor);

        var newLabelIndex = 1;

        tipNodes.forEach(node => {
            node.label = `n${newLabelIndex++}`;
        });

        if (rootNode) {
            rootNode.label = `n${newLabelIndex++}`;
        }

        internalNodes.forEach(node => {
            node.label = `n${newLabelIndex++}`;
        });

        // Update network data with sorted tip nodes
        nodesDataSet = new vis.DataSet([...tipNodes, rootNode, ...internalNodes]);
        edgesDataSet = new vis.DataSet(edges);

        var container = document.getElementById("mynetwork");
        var data = {
            nodes: nodesDataSet,
            edges: edgesDataSet,
        };
        var options = {
            layout: {
                hierarchical: {
                    direction: "UD",
                    sortMethod: "directed",
                    levelSeparation: 80,
                },
            },
            edges: {
                arrows: {
                    to: { enabled: true, scaleFactor: 1, type: "vee" },
                },
                chosen: {
                    edge: changeChosenEdge,
                },
            },
            nodes: {
                font: {
                    align: 'center',
                },
                chosen: {
                    node: changeChosenNode,
                },
            },
            interaction: {
                hover: true,
            },
        };
        network = new vis.Network(container, data, options);

        // Update adjacency list
        updateAdjacencyList(edges, nodesDataSet);
        // Update node features list
        updateNodeFeaturesList(edges, nodesDataSet);

        // Set up hover event listeners for the network
        network.on('hoverEdge', function(params) {
            highlightEdgeInLists(params.edge, true);
            // Set the edge to a new group
            edgesDataSet.update({ id: params.edge, group: 'highlight-edges' });
            // Set the edge to a new color
            edgesDataSet.update({ id: params.edge, color: 'yellow' });
        });

        network.on('blurEdge', function(params) {
            highlightEdgeInLists(params.edge, false);
            // Reset the edge group
            edgesDataSet.update({ id: params.edge, group: undefined });
            // Reset the edge color
            edgesDataSet.update({ id: params.edge, color: edgeColor });
        });

        network.on('hoverNode', function(params) {
            highlightNodeInLists(params.node, true);
            highlightNodeInNetwork(params.node, true);
        });

        network.on('blurNode', function(params) {
            highlightNodeInLists(params.node, false);
            highlightNodeInNetwork(params.node, false);
        });
    }

    // Function to update the adjacency list
    function updateAdjacencyList(edges, nodesDataSet) {
        const adjacencyList = {};
        let maxWidth = 0;

        // Calculate the max width for node labels
        nodesDataSet.forEach(node => {
            const nodeWidth = getTextWidth(node.label, '18px monospace');
            if (nodeWidth > maxWidth) {
                maxWidth = nodeWidth;
            }
        });

        edges.forEach(edge => {
            const fromNode = nodesDataSet.get(edge.from);
            const toNode = nodesDataSet.get(edge.to);
            const edgeLabel = `<span class="edge-label">${edge.label}</span>`;
            const colon = `<span class="colon">:</span>`;
            const fromLabel = `<span id="node-${fromNode.id}" class="node-container node-label-${fromNode.id}" style="color:${fromNode.color}; width:${maxWidth}px">${fromNode.label}</span>`;
            const comma = `<span class="brackets">,</span>`;
            const toLabel = `<span id="node-${toNode.id}" class="node-container node-label-${toNode.id}" style="color:${toNode.color}; width:${maxWidth}px">${toNode.label}</span>`;
            const brackets = `<span class="brackets">[</span>${fromLabel}${comma}${toLabel}<span class="brackets">]</span>`;

            adjacencyList[edge.id] = `<div id="row-${edge.id}" class="row-container">${edgeLabel}${colon}${brackets}</div>`;
        });

        let listString = '';
        Object.keys(adjacencyList).forEach(key => {
            listString += adjacencyList[key];
        });

        document.getElementById('adjacency-list').innerHTML = listString;

        // Add hover listeners to the adjacency list containers
        addHoverListenersToAdjacencyList();
    }

    // Function to update the node features list
    function updateNodeFeaturesList(edges, nodesDataSet) {
        const nodeFeaturesList = {};
        let maxWidth = 0;

        // Calculate the max width for edge labels
        edges.forEach(edge => {
            const edgeWidth = getTextWidth(edge.label, '18px monospace');
            if (edgeWidth > maxWidth) {
                maxWidth = edgeWidth;
            }
        });

        nodesDataSet.forEach(node => {
            const incomingEdge = edges.find(edge => edge.to === node.id);
            const outgoingEdges = edges.filter(edge => edge.from === node.id);

            const ancestorEdge = incomingEdge ? incomingEdge.label : '0';
            const daughterEdge1 = outgoingEdges[0] ? outgoingEdges[0].label : '0';
            const daughterEdge2 = outgoingEdges[1] ? outgoingEdges[1].label : '0';

            // Get node and edge colors
            const nodeColor = node.color || node.color.background;
            const edgeColor1 = incomingEdge ? edgeColor : 'gray'; // default to gray if no edge
            const edgeColor2 = outgoingEdges[0] ? edgeColor : 'gray';
            const edgeColor3 = outgoingEdges[1] ? edgeColor : 'gray';

            // Generate HTML with appropriate colors
            const edgeLabel1 = `<span id="edge-${incomingEdge ? incomingEdge.id : '0'}" class="edge-container" style="width:${maxWidth}px; color:${edgeColor1}">${ancestorEdge}</span>`;
            const edgeLabel2 = `<span id="edge-${outgoingEdges[0] ? outgoingEdges[0].id : '0'}" class="edge-container" style="width:${maxWidth}px; color:${edgeColor2}">${daughterEdge1}</span>`;
            const edgeLabel3 = `<span id="edge-${outgoingEdges[1] ? outgoingEdges[1].id : '0'}" class="edge-container" style="width:${maxWidth}px; color:${edgeColor3}">${daughterEdge2}</span>`;
            const colon = `<span class="colon">:</span>`;
            const brackets = `<span class="brackets">[</span>${edgeLabel1}<span class="brackets">,</span>${edgeLabel2}<span class="brackets">,</span>${edgeLabel3}<span class="brackets">]</span>`;

            nodeFeaturesList[node.id] = `<div id="node-feature-${node.id}" class="row-container">
            <span class="node-label" style="color:${nodeColor}">${node.label}</span>${colon}${brackets}</div>`;
        });

        let listString = '';
        Object.keys(nodeFeaturesList).forEach(key => {
            listString += nodeFeaturesList[key];
        });

        document.getElementById('node-features').innerHTML = listString;

        // Add hover listeners to the node features list containers
        addHoverListenersToNodeFeaturesList();
    }

    // Function to calculate text width
    function getTextWidth(text, font) {
        const canvas = document.createElement("canvas");
        const context = canvas.getContext("2d");
        context.font = font;
        const width = context.measureText(text).width;
        return width;
    }

    // Function to add hover listeners to the adjacency list containers
    function addHoverListenersToAdjacencyList() {
        // Hover listeners for rows (entire rows will highlight the corresponding edge)
        document.querySelectorAll('.row-container').forEach(container => {
            container.addEventListener('mouseenter', function() {
                const edgeId = container.id.replace('row-', '');
                highlightEdgeInNetwork(edgeId, true);
                highlightEdgeInLists(edgeId, true);
            });
            container.addEventListener('mouseleave', function() {
                const edgeId = container.id.replace('row-', '');
                highlightEdgeInNetwork(edgeId, false);
                highlightEdgeInLists(edgeId, false);
            });
        });

        // Hover listeners for nodes
        document.querySelectorAll('.node-container').forEach(container => {
            container.addEventListener('mouseenter', function() {
                const nodeId = container.id.replace('node-', '');
                // change node color to yellow
                highlightNodeInNetwork(nodeId, true);
                highlightNodeInLists(nodeId, true);
            });
            container.addEventListener('mouseleave', function() {
                const nodeId = container.id.replace('node-', '');
                highlightNodeInNetwork(nodeId, false);
                highlightNodeInLists(nodeId, false);
            });
        });
    }

    // Function to add hover listeners to the node features list containers
    function addHoverListenersToNodeFeaturesList() {
        // Hover listeners for rows (entire rows will highlight the corresponding node)
        document.querySelectorAll('.row-container').forEach(container => {
            container.addEventListener('mouseenter', function() {
                const nodeId = container.id.replace('node-feature-', '');
                highlightNodeInNetwork(nodeId, true);
                highlightNodeInLists(nodeId, true);
            });
            container.addEventListener('mouseleave', function() {
                const nodeId = container.id.replace('node-feature-', '');
                highlightNodeInNetwork(nodeId, false);
                highlightNodeInLists(nodeId, false);
            });
        });

        // Hover listeners for edges in node features
        document.querySelectorAll('.edge-container').forEach(container => {
            container.addEventListener('mouseenter', function() {
                const edgeId = container.id.replace('edge-', '');
                if (edgeId !== '0') {
                    highlightEdgeInNetwork(edgeId, true);
                    highlightEdgeInLists(edgeId, true);
                } else {
                    // Highlight the entire row if edge is 0 and disable row hover effect
                    const rowContainer = container.closest('.row-container');
                    rowContainer.classList.add('highlight-node-feature');
                    rowContainer.style.pointerEvents = 'none'; // Disable hover effect
                    highlightNodeInNetwork(rowContainer.id.replace('node-feature-', ''), true);
                    highlightNodeInLists(rowContainer.id.replace('node-feature-', ''), true);
                }
            });
            container.addEventListener('mouseleave', function() {
                const edgeId = container.id.replace('edge-', '');
                if (edgeId !== '0') {
                    highlightEdgeInNetwork(edgeId, false);
                    highlightEdgeInLists(edgeId, false);
                } else {
                    // Unhighlight the entire row if edge is 0 and re-enable row hover effect
                    const rowContainer = container.closest('.row-container');
                    rowContainer.classList.remove('highlight-node-feature');
                    rowContainer.style.pointerEvents = 'auto'; // Re-enable hover effect
                    highlightNodeInNetwork(rowContainer.id.replace('node-feature-', ''), false);
                    highlightNodeInLists(rowContainer.id.replace('node-feature-', ''), false);
                }
            });
        });
    }

    // Function to highlight or unhighlight an edge in both the adjacency list and node features list
    function highlightEdgeInLists(edgeId, highlight) {
        highlightEdgeInList(edgeId, highlight);
        highlightEdgeInNodeFeatures(edgeId, highlight);
    }

    // Function to highlight or unhighlight an edge in the adjacency list
    function highlightEdgeInList(edgeId, highlight) {
        const rowElement = document.getElementById(`row-${edgeId}`);
        if (rowElement) {
            if (highlight) {
                rowElement.classList.add('highlight');
            } else {
                rowElement.classList.remove('highlight');
            }
        }
    }

    // Function to highlight or unhighlight an edge in the node features list
    function highlightEdgeInNodeFeatures(edgeId, highlight) {
        const edgeElements = document.querySelectorAll(`.edge-container[id='edge-${edgeId}']`);
        edgeElements.forEach(element => {
            if (highlight) {
                element.classList.add('highlight');
            } else {
                element.classList.remove('highlight');
            }
        });
    }

    // Function to highlight or unhighlight node labels in both the adjacency list and node features list
    function highlightNodeInLists(nodeId, highlight) {
        highlightNodeInListLabels(nodeId, highlight);
        highlightNodeInNodeFeatures(nodeId, highlight);
    }

    // Function to highlight or unhighlight node labels in the adjacency list
    function highlightNodeInListLabels(nodeId, highlight) {
        const nodeElements = document.querySelectorAll(`.node-label-${nodeId}`);
        nodeElements.forEach(element => {
            if (highlight) {
                element.classList.add('label-highlight');
            } else {
                element.classList.remove('label-highlight');
            }
        });
    }

    // Function to highlight or unhighlight node labels in the node features list
    function highlightNodeInNodeFeatures(nodeId, highlight) {
        const rowElement = document.getElementById(`node-feature-${nodeId}`);
        if (rowElement) {
            if (highlight) {
                rowElement.classList.add('highlight-node-feature');
            } else {
                rowElement.classList.remove('highlight-node-feature');
                rowElement.classList.remove('highlight');
            }
        }
    }

    // Function to highlight or unhighlight an edge in the network
    function highlightEdgeInNetwork(edgeId, highlight) {
        const edgeOptions = highlight ? { color: { color: 'yellow' }, width: 3 } : { color: edgeColor, width: 1 };
        edgesDataSet.update({ id: edgeId, ...edgeOptions });
    }

    // Function to highlight or unhighlight a node in the network without altering the network structure
    function highlightNodeInNetwork(nodeId, highlight) {
        if (highlight) {
            network.selectNodes([nodeId], highlightEdges = false);
        } else {
            network.unselectAll();
        }
    }

    // Function to change the border dashes of a chosen node
    function changeChosenNode(values, id, selected, hovering) {
        values.borderDashes = [2, 2];
        values.borderColor = "blue";
        values.borderWidth = 2;
        values.shadowColor = "lightblue";
        values.shadowX = 0;
        values.shadowY = 0;
    }

    // Function to change the line dashes of a chosen edge
    function changeChosenEdge(values, id, selected, hovering) {
        values.dashes = [5, 5];
        values.edgeColor = "yellow";
    }

    // maintain a list of UD, LR, DU, RL,
    // create two functions for two rotation buttons (90 and -90) to change the layout by scrolling within the list
    var layoutList = ["UD", "LR", "DU", "RL"];
    var layoutIndex = 0;
    function rotateLayoutClockwise() {
        layoutIndex = (layoutIndex + 1) % layoutList.length;
        network.setOptions({
            layout: {
                hierarchical: {
                    direction: layoutList[layoutIndex],
                    sortMethod: "directed",
                },
            },
        });
    }

    function rotateLayoutCounterClockwise() {
        layoutIndex = (layoutIndex - 1 + layoutList.length) % layoutList.length;
        network.setOptions({
            layout: {
                hierarchical: {
                    direction: layoutList[layoutIndex],
                    sortMethod: "directed",
                },
            },
        });
    }
</script>
</body>
</html>